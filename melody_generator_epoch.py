import json
import numpy
import os
import sys
import time

from itertools import dropwhile, takewhile

# To run this, you will need numpy. An example call is this:
# py -3.7 .\melody_generator_epoch.py 1750-1799 -debug
# (or whichever era you want to look at instead of 1750-1799), and the
# flag -debug is optional which prints progress as the program runs.

# The program requires that you have the unique-grams generated for 
# the time period in the folder unique_ngrams_epochs,
# generated by n-gram_epoch_scraper.py, as well as a folder epochs_hmm
# with the same time periods which were generated by 
# n-gram_epoch_predicter.py from the unique_ngrams_epochs folder.

# Note: older time periods may give short melodies as a result of 
# few results/short branches.

epoch = sys.argv[1]
epoch_size = str(int(epoch[5:])-int(epoch[:4])+1)
debug = len(sys.argv) > 2 and sys.argv[2] == "-debug"

unique_ngrams_folder = os.path.join("unique_ngrams_epochs", epoch_size)
epochs_hmm_folder = os.path.join("epochs_hmm", epoch_size)

melody = []

unique_1_grams = open(os.path.join(unique_ngrams_folder, "unique-1-grams_epochs_"+epoch_size+".json"))
data = json.load(unique_1_grams)

first_markov = {}
total_count = data[epoch][0]

for line in data[epoch][1]:
    interval = ("".join([str(i) for i in list(line) if i.isdigit() or i == "-"]))
    first_markov[interval] = data[epoch][1][line]/total_count
    
k = first_markov.keys()
v = first_markov.values()

unique_1_grams.close()

melody.append(int(numpy.random.choice([*k], p=[*v])))

if debug:
    print("Building melody:", melody)

year_range = epoch
start_line = '  "{}": {{\n'.format(year_range)
is_not_start = lambda line: line != start_line
is_not_stop = lambda line: not line.startswith('  }')
for i in range(2, 13):
    t = time.time()
    file_name = str(i) + "-grams-epochs_hmm_" + epoch_size + ".json"
    with open(os.path.join(epochs_hmm_folder, file_name)) as istream:
        lines = dropwhile(is_not_start, istream)
        next(lines)
        lines = takewhile(is_not_stop, lines)
        text = '{' + ''.join(lines) + '}'
        data = json.loads(text)
        sequence = str(tuple(melody))
        try:
            k = data[sequence].keys()
            v = data[sequence].values()
            melody.append(int(numpy.random.choice([*k], p=[*v])))
        except KeyError:
            break
        if debug:
            print(melody)
            print("Time taken to get next interval: ", time.time() - t)
print(tuple(melody))
